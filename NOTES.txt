///////////////////////////////////////////////////////////////////////////////
// NOTES
///////////////////////////////////////////////////////////////////////////////

- Learn OpenGL:
    https://learnopengl.com/
    https://www.amazon.co.uk/dp/9090332561

- A fragment in OpenGL is all the data required for OpenGL to render a single pixel.

- In modern OpenGL it is required to define at least a custom vertex and fragment shader, since there are no default vertex/fragment shaders on the GPU.

- OpenGL shaders are written in the C-like language GLSL

- Shaders are programs that get some data in, processes it, and outputs some data. The output of a shader is then fed into another shader in the next step in the graphics pipeline.

- OpenGL only processes 3D coordinates when they're in a specific range between -1.0 and 1.0 on all 3 axes. All coordinates within this so called normalized device coordinates range will end up visible on the screen.

- The graphics pipeline (* sections where custom shaders can be injected):
    vertex data[] -> vertex shader* -> geometry shader* -> shape assembly -> rasterization -> fragment shader* -> tests and blending

- Vertex shader: Takes a single vertex as input. Can transform 3D coordinates into different 3D coordinates, and allows for some basic processing on the vertex attributes.

- Geometry shader: The output of the vertex shader is optionally passed to the geometry shader. Takes a collection of vertices that forms a primitive as input. Can generate other shapes by emitting new vertices to fomr new (or other) primitve(s).

- Primitive assembly: Takes all the vertices from the vertex (or geometry) shader that form one or more primitives as input. Assembles all the point(s) in the primitive shape given.

- Rasterization stage: The output of the primitve assembly stage is passed on and the resulting primitive(s) are mapped to the corresponding pixels on the final screen, resulting in framgents for the framgent shader to use. Before the fragment shaders run, clipping is performed, discarding all fragments that are outside the view.

- Fragment shader: Takes the fragments from the rasterizer as input. Calculates the final color of a pixel. Usually the fragment shader contains data about the 3D scene that it can use to calculate the final pixel color (like lights, shadows, color of the light, etc.)

- Alpha test and blending stage: This stage checks the corresponding depth (and stencil) value of the fragment and uses those to check if the resulting fragment is in from or behind other objects and should be discarded accordingly. Alpha values are also checked and objects are blended accordingly.

- In gl.BufferData() there are three options for how to manage the given data:
    + gl.STREAM_DRAW: The data is set only once and used by the GPU at most a few times.
    + gl.STATIC_DRAW: The data is set only once and used many times.
    + gl.DYNAMIC_DRAW: The data is changed a lot and used many times.

- Vertex shader inputs are called vertex attributes, and there are a set maximum number of attributes allowed, limited by the hardware. Some hardware supports more, but OpenGL guarantees that there are always at least 16 4-component vertex attributes available.

- The vertex shader should receive some form of input

- The fragment shader requires a vec4 color output variable

- GLSL data types:
    + Boolean:                   bool
    + Integer:                   int / uint
    + Floating-point number:     float / double
    + Vector (float):            vec2 / vec3 / vec 4

- GLSL vectors:
    + Vector (double):           dvec2 / dvec3 / dvec4
    + Vector (integer):          ivec2 / ivec3 / ivec4
    + Vector (unsigned integer): uvec2 / uvec3 / uvec4
    + Vector (boolean):          bvec2 / bvec3 / bvec4

- 3 ways to access the components of a vector:
    + v.x, v.y, v.z, v.w
    + v.r, v.g, v.r, v.a (used for colors)
    + v.s, v.t, v.p, v.q (used for texture coordinates)

- GLSL supports vector swizzling:
    vec2 someVec;
    vec4 differentVec = someVec.xyxx;
    vec3 anotherVec = differentVec.zyw;
    vec4 otherVec = someVec.xxxx + anotherVec.yxzy;

- Vectors can be passed as arguments to vector constructor calls:
    vec2 vect = vec2(0.5, 0.7);
    vec4 result = vec4(vect, 0.0, 0.0);
    vec4 otherResult = vec4(result.xyz, 1.0);